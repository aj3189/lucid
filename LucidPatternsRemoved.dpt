memop fst(int<<'a~0>> x,int<<'a~0>> y)
 {return x;}

memop snd(int<<'a~0>> x,int<<'a~0>> y)
 {return y;}

memop sum(int<<'a~0>> x,int<<'a~0>> y)
 {return x+y;}

memop diff(int<<'a~0>> x,int<<'a~0>> y)
 {return x-y;}

memop max(int<<'a~0>> x,int<<'a~0>> y)
 {if (x<y) {
return y;
} else {
return x;
}}

memop min(int<<'a~0>> x,int<<'a~0>> y)
 {if (x<y) {
return x;
} else {
return y;
}}

memop eq(int<<'a~0>> x,int<<'a~0>> y)
 {if (x==y) {
return 1;
} else {
return 0;
}}

memop gt(int<<'a~0>> x,int<<'a~0>> y)
 {if (x>y) {
return 1;
} else {
return 0;
}}

memop lt(int<<'a~0>> x,int<<'a~0>> y)
 {if (x<y) {
return 1;
} else {
return 0;
}}

memop incr(int<<'a~0>> x,int<<'a~0>> y)
 {return x+1;}

const NUM_REGISTERS int<<32>> = 10;

const TRUE int<<32>> = 1;

const FALSE int<<32>> = 0;

const head int<<9>> = 0;

const tail int<<9>> = 2;

const succ int<<9>> = 1;

const location int<<9>> = 0;

global Array.t<<32>> pending = Array.create(NUM_REGISTERS);


global Array.t<<32>> sequence_nums = Array.create(NUM_REGISTERS);


global Array.t<<32>> registers = Array.create(NUM_REGISTERS);


event write(int<<32>> idx,int<<32>> seq,int<<32>> data) ;

event ack(int<<32>> idx) ;

event process(int<<32>> src,int<<32>> dst,int<<32>> idx) ;

entry event pktin(int<<32>> src,int<<32>> dst) ;

exit event continue(int<<32>> src,int<<32>> dst) ;

memop tru(int<<32>> dummy,int<<32>> dummy2)
 {return TRUE;}

memop check_and_incr(int<<32>> curr,int<<32>> next)
 {if (next==curr+1) {
return next;
} else {
return curr;
}}

handle write(int<<32>> idx,int<<32>> seq,int<<32>> data) {
int<<32>> update_res = Array.update(pending,idx,fst,0,tru,0);
if (update_res==TRUE) {
generate write(idx,seq,data);
} else {
bool continue = true;
if (location==head) {
seq = Array.update(sequence_nums,idx,incr,1,incr,1);
} else {
int<<32>> seq2 = Array.update(sequence_nums,idx,check_and_incr,seq,check_and_incr,seq);
if (seq2!=seq) {
continue = false;
} 
}
if (continue==false) {
generate write(idx,seq,data);
} else {
Array.set(registers,idx,data);
if (location!=tail) {
generate_port (succ, write(idx,seq,data));
} else {
generate_port (head, ack(idx));
}
}
}
}

handle ack(int<<32>> idx) {
Array.set(pending,idx,FALSE);
if (location!=tail) {
generate_port (succ, ack(idx));
} 
}

fun bool need_to_write(int<<32>> src,int<<32>> dst) {
return false;
}

fun void process_fun(int<<32>> src,int<<32>> dst,int<<32>> idx) {
int<<32>> foo = Array.get(registers,idx);
if (foo==0) {
generate continue(src,dst);
} 
}

handle process(int<<32>> src,int<<32>> dst,int<<32>> idx) {
process_fun(src,dst,idx);
}

handle pktin(int<<32>> src,int<<32>> dst) {
bool ntw = need_to_write(src,dst);
if (ntw) {
generate_port (head, write(0,0,0));
} 
int<<32>> idx = hash<<32>>(0,src,dst);
int<<32>> r = Array.get(pending,idx);
if (r==TRUE) {
generate_port (tail, process(src,dst,idx));
} else {
process_fun(src,dst,idx);
}
}